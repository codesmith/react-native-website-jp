---
id: testing-overview
title: Testing
author: Vojtech Novak
authorURL: 'https://twitter.com/vonovak'
description: This guide introduces React Native developers to the key concepts behind testing, how to write good tests, and what kinds of tests you can incorporate into your workflow.
---

コードベースが拡大するにつれて、予期しない小さなエラーやエッジケースが、より大きな障害に発展する可能性があります。バグはユーザーエクスペリエンスの低下につながり、最終的にはビジネス上の損失につながります。壊れやすいプログラミングを防ぐ1つの方法は、コードを公開する前にテストすることです。

このガイドでは、静的分析からエンドツーエンドのテストまで、アプリが期待どおりに動作するようにするためのさまざまな自動化された方法について説明します。

<img src="/docs/assets/diagram_testing.svg" alt="Testing is a cycle of fixing, testing, and either passing to release or failing back into testing." />

## Why Test

私たちは人間です、そして人間は間違いを犯します。テストは、これらの間違いを発見し、コードが機能していることを確認するのに役立つため、重要です。おそらくもっと重要なのは、テストによって、新しい機能を追加したり、既存機能をリファクタリングしたり、プロジェクトの主要な依存関係をアップグレードしたりしても、コードが将来も引き続き機能することを確認することです。

テストには、思っている以上に価値があります。コードのバグを修正する最良の方法の1つは、失敗したテストを書いてそれを公開することです。その後、バグを修正してテストを再実行しても、合格すれば、バグは修正され、コードベースに再導入されることはありません。

テストは、チームに参加する新しい人のための文書としても役立ちます。コードベースを見たことがない人にとっては、テストを読むことで既存のコードがどのように機能するかを理解するのに役立ちます。

大事なことを言い忘れましたが、テストの自動化が進むと、手動の<abbr title="Quality Assurance">QA</abbr>に費やす時間が減り、貴重な時間を解放できます。

## Static Analysis

コード品質を向上させるための最初のステップは、静的分析ツールを使い始めることです。静的分析は、コードを書くときにエラーをチェックしますが、そのコードは実行しません。

- **Linters**はコードを分析して、未使用のコードなどの一般的なエラーをキャッチし、落とし穴を避け、スペースの代わりにタブを使用するなどの禁止事項を通知します（設定によっては逆も同様です）。
- **型チェック**は、関数に渡す構文が、関数が受け入れるように設計されたものと一致していることを確認します。たとえば、数字を必要とするカウント関数に文字列を渡すことを防ぎます。

React Native には、そのようなツールが2つ付属しています。リンティング用の [ESLint](https://eslint.org/) と、型チェック用の [TypeScript](typescript) です。

## Writing Testable Code

テストを始めるには、まずテスト可能なコードを書く必要があります。航空機の製造プロセスを考えてみましょう。複雑なシステムがすべて連携して機能することを示すために、モデルが最初に離陸する前に、個々の部品をテストして、安全で正しく機能することを保証します。たとえば、翼は極度の負荷をかけて曲げることでテストされます。エンジン部品の耐久性はテストされ、フロントガラスは鳥の衝撃を模倣してテストされます。

ソフトウェアは似ています。プログラム全体を、何行ものコードを含む1つの巨大なファイルに記述する代わりに、組み立てられた全体をテストするよりも徹底的にテストできる複数の小さなモジュールにコードを記述します。このように、テスト可能なコードを書くことは、クリーンでモジュラーなコードを書くことと絡み合っています。

アプリをよりテストしやすくするには、まずアプリのビュー部分、つまりReactコンポーネントをビジネスロジックやアプリのstate から分離することから始めます（Redux、MobX、その他のソリューションを使用しているかどうかは関係ありません）。こうすることで、ビジネスロジックのテスト（Reactコンポーネントに頼るべきではない）を、主にアプリのUIをレンダリングするコンポーネント自体から独立させることができます！

理論的には、すべてのロジックとデータフェッチをコンポーネントから外すことができます。この方法では、コンポーネントはレンダリング専用になります。state はコンポーネントから完全に独立しています。アプリのロジックは、Reactコンポーネントがまったくなくても機能します！

> テスト可能なコードのトピックは、他の学習リソースでさらに詳しく調べることをお勧めします。

## Writing Tests

テスト可能なコードを書いたら、実際のテストを書いてみましょう！React Native のデフォルトテンプレートには、[Jest](https://jestjs.io) テストフレームワークが付属しています。この環境に合わせたプリセットが含まれているので、構成やモックをすぐに微調整することなく生産性を高めることができます。[モックの詳細](#mocking) は後ほど説明します。Jestを使って、このガイドで紹介されているあらゆる種類のテストを書くことができます。

> テスト駆動開発を行うなら、実際には最初にテストを書きます！そうすれば、コードのテストが容易になります。

### Structuring Tests

テストは短く、理想的には1つのことだけをテストしてください。まず、Jestで書かれたユニットテストの例から始めましょう。

```js
it('given a date in the past, colorForDueDate() returns red', () => {
  expect(colorForDueDate('2000-10-20')).toBe('red');
});
```

テストは [`it`](https://jestjs.io/docs/en/api#testname-fn-timeout) 関数に渡される文字列によって記述されます。何がテストされているかが明確になるように、説明を注意深く書いてください。次のことをカバーできるよう最善を尽くしてください：

1. **Given** -いくつかの前提条件
2. **When** -テストしている関数によって実行されるアクション
3. **Then** -期待される結果

これはAAA（アレンジ、アクト、アサート）とも呼ばれます。

Jestは、テストの構成に役立つ [`describe`](https://jestjs.io/docs/en/api#describename-fn) 機能を提供しています。1つの機能に属するすべてのテストをまとめるには、`describe`を使用してください。必要であれば、説明をネストできます。他に一般的に使用する関数は、テストするオブジェクトの設定に使用できる [`beforeEach`](https://jestjs.io/docs/en/api#beforeeachfn-timeout) または [`beforeAll`](https://jestjs.io/docs/en/api#beforeallfn-timeout) です。詳細については、[Jest apiリファレンス](https://jestjs.io/docs/en/api) をご覧ください。

テストに多くのステップや期待値がある場合は、複数の小さなテストに分割したほうがいいでしょう。また、テストが互いに完全に独立していることを確認してください。スイート内の各テストは、最初に他のテストを実行せずに単独で実行できる必要があります。逆に、すべてのテストをまとめて実行する場合、最初のテストが2番目のテストの結果に影響を与えてはいけません。

最後に、開発者としては、コードがうまく機能し、クラッシュしないのが好きです。テストでは、これはしばしば逆です。失敗したテストを_良いことと考えてください!_ テストが失敗するのは、多くの場合、何かがおかしいということです。これにより、ユーザーに影響が及ぶ前に問題を解決する機会が得られます。

## Unit Tests

ユニットテストは、個々の関数やクラスなど、コードの最も小さな部分を対象としています。

テスト対象のオブジェクトに依存関係がある場合は、次の段落で説明するように、しばしばモックアウトする必要があります。

ユニットテストの素晴らしいところは、記述と実行が速いことです。そのため、作業を進めていくと、テストが合格したかどうかのフィードバックがすぐに得られます。Jestには、編集中のコードに関連するテストを継続的に実行するオプションもあります。 [Watch mode](https://jestjs.io/docs/en/cli#watch).

<img src="/docs/assets/p_tests-unit.svg" alt=" " />

### Mocking

テストしたオブジェクトに外部依存関係がある場合、「モックアウト」したくなることがあります。「モッキング」とは、コードの依存関係の一部を独自の実装に置き換えることです。

> 一般的に、テストではモックを使用するよりも実際のオブジェクトを使用する方が良いですが、それが不可能な状況もあります。たとえば、JSユニットテストがJavaまたはObjective-Cで記述されたネイティブモジュールに依存している場合。

あなたの街の現在の天気を表示するアプリを書いていて、天気情報を提供する外部サービスやその他の依存関係を使っていると想像してみてください。雨が降っているとサービスから通知されたら、雨雲の画像を見せてください。テストでそのサービスを呼び出したくありません。理由は次のとおりです。

- テストが遅くなったり、不安定になったりする可能性があります（ネットワークリクエストが原因で）
- サービスは、テストを実行するたびに異なるデータを返すことがあります
- どうしてもテストを実行する必要があるときに、サードパーティのサービスがオフラインになることがあります！

そのため、サービスの模擬実装を提供して、何千行ものコードやインターネットに接続された温度計を効果的に置き換えることができます！

> Jestには、機能レベルからモジュールレベルのモックまで、[モッキングのサポート](https://jestjs.io/docs/en/mock-functions#mocking-modules) が付属しています。

## Integration Tests

大規模なソフトウェアシステムを書くときは、その個々の部分が相互に作用する必要があります。ユニットテストで、あなたのユニットが別のユニットに依存している場合、その依存関係をモッキングして、偽物に置き換えてしまうことがあります。

統合テストでは、実際の個々のユニットを（アプリと同じように）組み合わせてテストし、連携が期待どおりに機能することを確認します。ここでモッキングが起こらないということではありません。モック（たとえば、気象局との通信を模擬するため）は必要ですが、ユニットテストよりもはるかに少なくて済みます。

> 統合テストの意味に関する用語は、常に一貫しているわけではないことに注意してください。また、ユニットテストと統合テストとの境界線は、必ずしも明確ではありません。このガイドでは、次の条件に当てはまる場合、テストは「統合テスト」に該当します。
>
> - 上記のように、アプリの複数のモジュールを組み合わせます
> - 外部システムを使います
> - 他のアプリケーション（気象サービスAPIなど）にネットワーク呼び出しを行います
> - あらゆる種類のファイルまたはデータベースの<abbr title="Input/Output">I/O</abbr>を行います

<img src="/docs/assets/p_tests-integration.svg" alt=" " />

## Component Tests

Reactコンポーネントはアプリのレンダリングを担当し、ユーザーはその出力を直接操作します。アプリのビジネスロジックのテスト範囲が広く、正確であっても、コンポーネントテストを行わないと、壊れたUIをユーザーに提供してしまう可能性があります。コンポーネントテストはユニットテストと統合テストの両方に分類できますが、React Native の中核部分なので、個別に説明します。

Reactコンポーネントをテストする場合、テストしたいことが2つあります。

- インタラクション：ユーザーが操作したとき（たとえば、ユーザーがボタンを押したときなど）にコンポーネントが正しく動作することを確認するため
- レンダリング：Reactが使用するコンポーネントのレンダリング出力が正しいことを確認するため（たとえば、ボタンの外観やUIでの配置）

たとえば、「onPress」リスナー付きのボタンがある場合、ボタンが正しく表示され、ボタンをタップすることがコンポーネントによって正しく処理されるかどうかをテストする必要があります。

これらをテストするのに役立つライブラリがいくつかあります：

- コアと並行して開発されたReactの [テストレンダラー](https://reactjs.org/docs/test-renderer.html) は、DOMやネイティブのモバイル環境に依存せずに、Reactコンポーネントを純粋なJavaScriptオブジェクトにレンダリングするために使用できるReactレンダラーを提供します。
- [React Native テストライブラリ](https://callstack.github.io/react-native-testing-library/) はReactのテストレンダラーの上に構築され、次の段落で説明する `fireEvent`と`query` APIを追加しています。

> コンポーネントテストは、Node.js 環境で実行されている JavaScript テストだけです。React Native コンポーネントを支えているiOS、Android、その他のプラットフォームコードは考慮されていません。つまり、すべてがユーザーにとってうまくいくという100％の自信を与えることはできません。iOSやAndroidのコードにバグがあると、見つかりません。

<img src="/docs/assets/p_tests-component.svg" alt=" " />

### Testing User Interactions

一部のUIのレンダリングとは別に、コンポーネントは「TextInput」の「onChangeText」や「Button」の「onPress」などのイベントを処理します。また、他の関数やイベントコールバックが含まれている場合もあります。次の例を考えてみましょう。

```tsx
function GroceryShoppingList() {
  const [groceryItem, setGroceryItem] = useState('');
  const [items, setItems] = useState<string[]>([]);

  const addNewItemToShoppingList = useCallback(() => {
    setItems([groceryItem, ...items]);
    setGroceryItem('');
  }, [groceryItem, items]);

  return (
    <>
      <TextInput
        value={groceryItem}
        placeholder="Enter grocery item"
        onChangeText={text => setGroceryItem(text)}
      />
      <Button
        title="Add the item to list"
        onPress={addNewItemToShoppingList}
      />
      {items.map(item => (
        <Text key={item}>{item}</Text>
      ))}
    </>
  );
}
```

ユーザーインタラクションをテストするときは、ユーザーの視点からコンポーネントをテストしてください。ページには何がありますか？インタラクションすると何が変わりますか？

経験則として、ユーザーが見たり聞いたりできるものを使用することを好みます。

- レンダリングされたテキストまたは [アクセシビリティヘルパー](https://reactnative.dev/docs/accessibility#accessibility-properties) を使用してアサーションを行います

逆に、次のことは避けてください。

- コンポーネントの props や state についてアサーションをする
- テストIDクエリ

propsやstateなどの実装の詳細をテストすることは避けてください。このようなテストは機能しますが、ユーザーがコンポーネントをどのように操作するかを重視しておらず、リファクタリングによって機能しなくなる傾向があります（たとえば、名前を変更したり、フックを使用してクラスコンポーネントを書き直したりする場合）。

> Reactクラスのコンポーネントは、特に内部state、小道具、イベントハンドラーなどの実装の詳細をテストする傾向があります。実装の詳細をテストするのを避けるには、フック付きの関数コンポーネントを使用することをお勧めします。これにより、コンポーネント内部への依存が_困難_になります。

[React Native Testing Library](https://callstack.github.io/react-native-testing-library/) などのコンポーネントテストライブラリは、提供されているAPIを慎重に選択することで、ユーザー中心のテストを書くのに役立ちます。次の例では、ユーザーがコンポーネントを操作するのをシミュレートする `fireEvent`のメソッドである`changeText`や`press`メソッドと、レンダリングされた出力で一致する「Text」ノードを見つけるクエリ関数 `getAllByText`を使用しています。

```tsx
test('given empty GroceryShoppingList, user can add an item to it', () => {
  const {getByPlaceholderText, getByText, getAllByText} = render(
    <GroceryShoppingList />,
  );

  fireEvent.changeText(
    getByPlaceholderText('Enter grocery item'),
    'banana',
  );
  fireEvent.press(getByText('Add the item to list'));

  const bananaElements = getAllByText('banana');
  expect(bananaElements).toHaveLength(1); // expect 'banana' to be on the list
});
```

この例は、関数を呼び出したときにstate がどのように変化するかをテストするものではありません。ユーザーが `TextInput `のテキストを変更して「Button」を押すとどうなるかをテストします！

### Testing Rendered Output

[スナップショットテスト](https://jestjs.io/docs/en/snapshot-testing) は、Jestによって可能になる高度な種類のテストです。これは非常に強力で低レベルのツールなので、使用するときは特に注意が必要です。

「コンポーネントスナップショット」は、Jestに組み込まれたカスタムReactシリアライザーによって作成されたJSXのような文字列です。このシリアライザーにより、JestはReactコンポーネントツリーを人間が読める文字列に変換できます。別の言い方をすれば、コンポーネントスナップショットは、テスト実行中に出力されたコンポーネントのレンダリング出力をテキストで表現したものです。このようになるかもしれません：

```tsx
<Text
  style={
    Object {
      "fontSize": 20,
      "textAlign": "center",
    }
  }>
  Welcome to React Native!
</Text>
```

スナップショットテストでは、通常、最初にコンポーネントを実装してからスナップショットテストを実行します。次に、スナップショットテストではスナップショットを作成し、それを参照スナップショットとしてリポジトリのファイルに保存します。**その後、ファイルはコミットされ、コードレビュー中にチェックされます**。コンポーネントのレンダリング出力に今後変更を加えると、そのスナップショットが変更され、テストは失敗します。次に、テストに合格するには、保存されている参照スナップショットを更新する必要があります。その変更を再度コミットして確認する必要があります。

スナップショットにはいくつかの弱点があります。

- 開発者またはレビュアーにとって、スナップショットの変更が意図されたものなのか、それともバグの証拠なのかを見分けるのは難しいかもしれません。特に大きなスナップショットはすぐにわかりにくくなり、付加価値が低くなります。
- スナップショットが作成されると、レンダリングされた出力が実際に間違っている場合でも、その時点で正しいと見なされます。
- スナップショットに障害が発生すると、変更が予想されるかどうかを調査するための適切な注意を払わずに、「--updateSnapshot」jestオプションを使用してスナップショットを更新したくなります。したがって、開発者には一定の規律が必要です。

スナップショット自体は、コンポーネントのレンダリングロジックが正しいことを保証するものではありません。予期しない変更を防ぎ、テスト対象のReactツリーのコンポーネントが期待される小道具（スタイルなど）を受け取っていることを確認するのに優れているだけです。

小さいスナップショットのみを使用することをお勧めします（[`大容量スナップショットなし` ルール](https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md) を参照）。Reactコンポーネントの2つの状態間の_変更_をテストしたい場合は、[`snapshot-diff`](https://github.com/jest-community/snapshot-diff) を使用してください。疑わしい場合は、前の段落で説明したような明確な期待値を付けてください。

<img src="/docs/assets/p_tests-snapshot.svg" alt=" " />

## End-to-End Tests

エンドツーエンド（E2E）テストでは、デバイス（またはシミュレーター/エミュレーター）上でアプリがユーザーの観点から期待どおりに動作していることを確認します。

これは、リリース構成でアプリを構築し、それに対してテストを実行することによって行われます。E2Eテストでは、Reactコンポーネント、React Native API、Reduxストア、またはビジネスロジックについてはもう考えません。それはE2Eテストの目的ではなく、E2Eテスト中にもアクセスできません。

代わりに、E2Eテストライブラリを使用すると、アプリの画面内の要素を見つけて制御できます。たとえば、実際のユーザーと同じように、ボタンを_実際に_タップしたり、`TextInputs`にテキストを挿入したりできます。次に、アプリの画面に特定の要素が存在するかどうか、表示されているかどうか、含まれているテキストなどについて断言できます。

E2Eテストでは、アプリの一部が機能していることを可能な限り確信できます。トレードオフには以下が含まれます：

- それらを書くのは、他の種類のテストに比べて時間がかかります
- 実行が遅いです
- 不安定になりやすいです（「不安定な」テストとは、コードを変更せずにランダムに合格/不合格になるテストです）

認証フロー、コア機能、支払いなど、アプリの重要な部分をE2Eテストでカバーするようにしてください。アプリの重要でない部分には、より高速なJSテストを使用してください。テストを追加すればするほど、自信が高まりますが、テストの保守と実行に費やす時間が長くなります。トレードオフを考えて、あなたにとって何が最善かを決めてください。

E2Eテストツールはいくつかあります。React Native コミュニティでは、[Detox](https://github.com/wix/detox/) はReact Native アプリ向けに作られているので人気のあるフレームワークです。iOSとAndroidアプリの分野で人気のあるもう1つのライブラリは、[Appium](http://appium.io/) または [Maestro](https://maestro.mobile.dev/) です。

<img src="/docs/assets/p_tests-e2e.svg" alt=" " />

## Summary

このガイドを読んで楽しんで、何かを学んだことを願っています。アプリをテストする方法はたくさんあります。最初は何を使うか決めるのが難しいかもしれません。しかし、素晴らしいReact Native アプリにテストを追加し始めたら、すべてが理にかなっていると信じています。あなたは今何を待っていますか？カバレッジを上げてください！

### Links

- [React testing overview](https://reactjs.org/docs/testing.html)
- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)
- [Jest docs](https://jestjs.io/docs/en/tutorial-react-native)
- [Detox](https://github.com/wix/detox/)
- [Appium](http://appium.io/)
- [Maestro](https://maestro.mobile.dev/)

---

_This guide originally authored and contributed in full by [Vojtech Novak](https://twitter.com/vonovak)._
